use crate::serde_utils::{serialize_signature, deserialize_signature, serialize_32_bytes, deserialize_32_bytes};
use chrono::Utc;
use serde::{Deserialize, Serialize};

/// IronShield Challenge structure for the proof-of-work algorithm
/// 
/// * `random_nonce`:     The SHA-256 hash of a random number (hex string).
/// * `created_time`:     Unix milli timestamp for the challenge.
/// * `expiration_time`:  Unix milli timestamp for the challenge expiration time.
/// * `challenge_param`:  Target threshold - hash must be less than this value.
/// * `website_id`:       The identifier of the website.
/// * `public_key`:       Ed25519 public key for signature verification.
/// * `challenge_signature`: Ed25519 signature over the challenge data.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IronShieldChallenge {
    pub random_nonce:        String,
    pub created_time:        i64,
    pub expiration_time:     i64,
    pub website_id:          String,
    #[serde(
        serialize_with = "serialize_32_bytes",
        deserialize_with = "deserialize_32_bytes"
    )]
    pub challenge_param:     [u8; 32],
    #[serde(
        serialize_with = "serialize_32_bytes",
        deserialize_with = "deserialize_32_bytes"
    )]
    pub public_key:          [u8; 32],
    #[serde(
        serialize_with = "serialize_signature",
        deserialize_with = "deserialize_signature"
    )]
    pub challenge_signature: [u8; 64],
}

impl IronShieldChallenge {
    /// Constructor for creating a new IronShieldChallenge instance.
    pub fn new(
        random_nonce:     String,
        created_time:     i64,
        website_id:       String,
        challenge_param:  [u8; 32],
        public_key:       [u8; 32],
        signature:        [u8; 64],
    ) -> Self {
        Self {
            random_nonce,
            created_time,
            website_id,
            expiration_time: created_time + 30_000, // 30 seconds
            challenge_param,
            public_key,
            challenge_signature: signature,
        }
    }

    /// Check if the challenge has expired.
    pub fn is_expired(&self) -> bool {
        Utc::now().timestamp_millis() > self.expiration_time
    }

    /// Returns the remaining time until expiration in milliseconds.
    pub fn time_until_expiration(&self) -> i64 {
        self.expiration_time - Utc::now().timestamp_millis()
    }

    /// Concatenates the challenge data into a string.
    ///
    /// Concatenates:
    /// - `random_nonce`     as a string.
    /// - `created_time`     as i64.
    /// - `expiration_time`  as i64.
    /// - `website_id`       as a string.
    /// - `public_key`       as a lowercase hex string.
    /// - `challenge_params` as a lowercase hex string.
    pub fn concat_struct(&self) -> String {
        format!(
            "{}|{}|{}|{}|{}|{}|{}",
            self.random_nonce,
            self.created_time,
            self.expiration_time,
            self.website_id,
            // We need to encode the byte arrays for format! to work.
            hex::encode(self.challenge_param),
            hex::encode(self.public_key),
            hex::encode(self.challenge_signature)
        )
    }

    /// Creates an `IronShieldChallenge` from a concatenated string.
    ///
    /// This function reverses the operation of
    /// `IronShieldChallenge::concat_struct`.
    /// Expects a string in the format:
    /// "random_nonce|created_time|expiration_time|website_id|challenge_params|public_key|challenge_signature"
    ///
    /// # Arguments
    ///
    /// * `concat_str`: The concatenated string to parse, typically
    ///                 generated by `concat_struct()`.
    ///
    /// # Returns
    ///
    /// * `Result<Self, String>`: A result containing the parsed
    ///                           `IronShieldChallenge` or an 
    ///                           error message if parsing fails.
    pub fn from_concat_struct(concat_str: &str) -> Result<Self, String> {
        let parts: Vec<&str> = concat_str.split('|').collect();

        if parts.len() != 7 {
            return Err(format!("Expected 7 parts, got {}", parts.len()));
        }

        let random_nonce = parts[0].to_string();

        let created_time = parts[1].parse::<i64>()
            .map_err(|_| "Failed to parse created_time as i64")?;

        let expiration_time = parts[2].parse::<i64>()
            .map_err(|_| "Failed to parse expiration_time as i64")?;

        let website_id = parts[3].to_string();

        let challenge_param_bytes = hex::decode(parts[4])
            .map_err(|_| "Failed to decode challenge_params hex string")?;
        let challenge_param: [u8; 32] = challenge_param_bytes
            .try_into()
            .map_err(|_| "Challenge params must be exactly 32 bytes")?;

        let public_key_bytes = hex::decode(parts[5])
            .map_err(|_| "Failed to decode public_key hex string")?;
        let public_key: [u8; 32] = public_key_bytes.try_into()
            .map_err(|_| "Public key must be exactly 32 bytes")?;

        let signature_bytes = hex::decode(parts[6])
            .map_err(|_| "Failed to decode challenge_signature hex string")?;
        let challenge_signature: [u8; 64] = signature_bytes
            .try_into()
            .map_err(|_| "Signature must be exactly 64 bytes")?;

        Ok(Self {
            random_nonce,
            created_time,
            expiration_time,
            website_id,
            challenge_param,
            public_key,
            challenge_signature,
        })
    }
} 