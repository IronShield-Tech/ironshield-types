use crate::serde_utils::{serialize_signature, deserialize_signature};
use serde::{Deserialize, Serialize};

/// IronShield Challenge Response structure
/// 
/// * `challenge_signature`: The Ed25519 signature of the challenge (copied from challenge).
/// * `solution`:            The nonce solution found by the proof-of-work algorithm.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IronShieldChallengeResponse {
    #[serde(
        serialize_with = "serialize_signature",
        deserialize_with = "deserialize_signature"
    )]
    pub challenge_signature: [u8; 64],
    pub solution:            i64,
}

impl IronShieldChallengeResponse {
    /// Constructor for creating a new IronShieldChallengeResponse instance.
    pub fn new(challenge_signature: [u8; 64], solution: i64) -> Self {
        Self {
            challenge_signature,
            solution,
        }
    }

    /// Concatenates the response data into a string.
    ///
    /// Concatenates:
    /// - `challenge_signature` as a lowercase hex string.
    /// - `solution`:           as a string.
    pub fn concat_struct(&self) -> String {
        format!(
            "{}|{}",
            // Use of hex::encode to convert the signature to a hex string
            // "Encodes data as hex string using lowercase characters."
            // Requirement of `format!`.
            hex::encode(self.challenge_signature),
            self.solution
        )
    }

    /// Creates an `IronShieldChallengeResponse` from a concatenated string.
    ///
    /// This function reverses the operation of
    /// `IronShieldChallengeResponse::concat_struct`.
    /// Expects a string in the format: "hex_signature|solution".
    ///
    /// # Arguments
    /// * `concat_string`: The concatenated string to parse, typically
    ///                    generated by `concat_struct()`.
    ///
    /// # Returns
    /// * `Result<Self, String>`: A result containing the parsed 
    ///                           `IronShieldChallengeResponse`
    ///                           or an error message if parsing fails.
    pub fn from_concat_struct(concat_string: &str) -> Result<Self, String> {
        let parts: Vec<&str> = concat_string.split('|').collect();

        if parts.len() != 2 {
            return Err(format!("Expected 2 parts, got {}", parts.len()));
        }

        let signature_bytes = hex::decode(parts[0])
            .map_err(|_| "Failed to decode challenge_signature hex string")?;
        let challenge_signature: [u8; 64] = signature_bytes.try_into()
            .map_err(|_| "Challenge signature must be exactly 64 bytes")?;
        
        let solution = parts[1].parse::<i64>()
            .map_err(|_| "Failed to parse solution as i64")?;

        Ok(Self {
            challenge_signature,
            solution,
        })
    }

    /// Encodes the response as a base64url string for HTTP header transport.
    /// 
    /// This method concatenates all response fields using the established `|` delimiter
    /// format, and then base64url-encodes the result for safe transport in HTTP headers.
    /// 
    /// # Returns
    /// * `String` - Base64url-encoded string ready for HTTP header use
    /// 
    /// # Example
    /// ```
    /// use ironshield_types::IronShieldChallengeResponse;
    /// let response = IronShieldChallengeResponse::new([0xAB; 64], 12345);
    /// let header_value = response.to_base64url_header();
    /// // Use header_value in HTTP header: "X-IronShield-Challenge-Response: {header_value}"
    /// ```
    pub fn to_base64url_header(&self) -> String {
        crate::serde_utils::concat_struct_base64url_encode(&self.concat_struct())
    }

    /// Decodes a base64url-encoded response from an HTTP header.
    /// 
    /// This method reverses the `to_base64url_header()` operation by first base64url-decoding
    /// the input string and then parsing it using the established `|` delimiter format.
    /// 
    /// # Arguments
    /// * `encoded_header` - The base64url-encoded string from the HTTP header
    /// 
    /// # Returns
    /// * `Result<Self, String>` - Decoded response or detailed error message
    /// 
    /// # Example
    /// ```
    /// use ironshield_types::IronShieldChallengeResponse;
    /// // Create a response and encode it
    /// let original = IronShieldChallengeResponse::new([0xAB; 64], 12345);
    /// let header_value = original.to_base64url_header();
    /// // Decode it back
    /// let decoded = IronShieldChallengeResponse::from_base64url_header(&header_value).unwrap();
    /// assert_eq!(original.solution, decoded.solution);
    /// ```
    pub fn from_base64url_header(encoded_header: &str) -> Result<Self, String> {
        // Decode using the existing serde_utils function.
        let concat_str: String = crate::serde_utils::concat_struct_base64url_decode(encoded_header.to_string())?;
        
        // Parse using the existing concat_struct format.
        Self::from_concat_struct(&concat_str)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_response_base64url_header_encoding_roundtrip() {
        // Create a test response.
        let response: IronShieldChallengeResponse = IronShieldChallengeResponse::new([0xAB; 64], 12345);

        // Test base64url encoding and decoding.
        let encoded: String = response.to_base64url_header();
        let decoded: IronShieldChallengeResponse = IronShieldChallengeResponse::from_base64url_header(&encoded).unwrap();

        // Verify all fields are preserved through a round-trip.
        assert_eq!(response.challenge_signature, decoded.challenge_signature);
        assert_eq!(response.solution, decoded.solution);
    }

    #[test]
    fn test_response_base64url_header_invalid_data() {
        // Test invalid base64url.
        let result: Result<IronShieldChallengeResponse, String> = IronShieldChallengeResponse::from_base64url_header("invalid-base64!");
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("Base64 decode error"));

        // Test valid base64url but invalid concatenated format.
        use base64::{Engine, engine::general_purpose::URL_SAFE_NO_PAD};
        let invalid_format: String = URL_SAFE_NO_PAD.encode(b"only_one_part");
        let result: Result<IronShieldChallengeResponse, String> = IronShieldChallengeResponse::from_base64url_header(&invalid_format);
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("Expected 2 parts"));
    }

    #[test]
    fn test_concat_struct() {
        let response = IronShieldChallengeResponse::new([0; 64], 42);
        let concat = response.concat_struct();
        assert_eq!(concat, format!("{}|{}", hex::encode([0; 64]), 42.to_string()));
    }

    #[test]
    fn test_from_concat_struct() {
        let concat = format!("{}|{}", hex::encode([0; 64]), 42);
        let response = IronShieldChallengeResponse::from_concat_struct(&concat).unwrap();
        assert_eq!(response.challenge_signature, [0; 64]);
        assert_eq!(response.solution, 42);
    }

    #[test]
    fn test_from_concat_struct_edge_cases() {
        // Test with a valid minimum length hex (64 bytes = 128 hex chars).
        // Building a string programmatically.
        let valid_hex = "0".repeat(128);
        assert_eq!(valid_hex.len(), 128, "Hex string should be exactly 128 characters for 64 bytes");

        let input = format!("{}|0", valid_hex);
        let result = IronShieldChallengeResponse::from_concat_struct(&input);

        if result.is_err() {
            panic!("Expected success but got error: {}", result.unwrap_err());
        }

        let parsed = result.unwrap();
        assert_eq!(parsed.challenge_signature, [0u8; 64]);
        assert_eq!(parsed.solution, 0);

        // Test with all F's hex.
        let all_f_hex = "f".repeat(128);
        assert_eq!(all_f_hex.len(), 128, "All F's hex string should be exactly 128 characters");

        let input = format!("{}|-1", all_f_hex);
        let result = IronShieldChallengeResponse::from_concat_struct(&input);

        if result.is_err() {
            panic!("Expected success but got error: {}", result.unwrap_err());
        }

        let parsed = result.unwrap();
        assert_eq!(parsed.challenge_signature, [0xffu8; 64]);
        assert_eq!(parsed.solution, -1);
    }
}