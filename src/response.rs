use crate::serde_utils::{serialize_signature, deserialize_signature};
use serde::{Deserialize, Serialize};

/// IronShield Challenge Response structure
/// 
/// * `challenge_signature`: The Ed25519 signature of the challenge (copied from challenge).
/// * `solution`:            The nonce solution found by the proof-of-work algorithm.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IronShieldChallengeResponse {
    #[serde(
        serialize_with = "serialize_signature",
        deserialize_with = "deserialize_signature"
    )]
    pub challenge_signature: [u8; 64],
    pub solution:            i64,
}

impl IronShieldChallengeResponse {
    /// Constructor for creating a new IronShieldChallengeResponse instance.
    pub fn new(challenge_signature: [u8; 64], solution: i64) -> Self {
        Self {
            challenge_signature,
            solution,
        }
    }

    /// Concatenates the response data into a string.
    ///
    /// Concatenates:
    /// - `challenge_signature` as a lowercase hex string.
    /// - `solution`:           as a string.
    pub fn concat_struct(&self) -> String {
        format!(
            "{}|{}",
            // Use of hex::encode to convert the signature to a hex string
            // "Encodes data as hex string using lowercase characters."
            // Requirement of `format!`.
            hex::encode(self.challenge_signature),
            self.solution
        )
    }

    /// Creates an `IronShieldChallengeResponse` from a concatenated string.
    ///
    /// This function reverses the operation of
    /// `IronShieldChallengeResponse::concat_struct`.
    /// Expects a string in the format: "hex_signature|solution".
    ///
    /// # Arguments
    /// * `concat_string`: The concatenated string to parse, typically
    ///                    generated by `concat_struct()`.
    ///
    /// # Returns
    /// * `Result<Self, String>`: A result containing the parsed 
    ///                           `IronShieldChallengeResponse`
    ///                           or an error message if parsing fails.
    pub fn from_concat_struct(concat_string: &str) -> Result<Self, String> {
        let parts: Vec<&str> = concat_string.split('|').collect();

        if parts.len() != 2 {
            return Err(format!("Expected 2 parts, got {}", parts.len()));
        }

        let signature_bytes = hex::decode(parts[0])
            .map_err(|_| "Failed to decode challenge_signature hex string")?;
        let challenge_signature: [u8; 64] = signature_bytes.try_into()
            .map_err(|_| "Challenge signature must be exactly 64 bytes")?;
        
        let solution = parts[1].parse::<i64>()
            .map_err(|_| "Failed to parse solution as i64")?;

        Ok(Self {
            challenge_signature,
            solution,
        })
    }
} 