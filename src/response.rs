use crate::serde_utils::{serialize_signature, deserialize_signature};
use serde::{Deserialize, Serialize};

/// IronShield Challenge Response structure
///
/// * `challenge_signature`: The Ed25519 signature of the challenge (copied from challenge).
/// * `solution`:            The nonce solution found by the proof-of-work algorithm.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IronShieldChallengeResponse {
    #[serde(
        serialize_with = "serialize_signature",
        deserialize_with = "deserialize_signature"
    )]
    pub challenge_signature: [u8; 64],
    pub solution:            i64,
}

impl IronShieldChallengeResponse {
    /// Constructor for creating a new IronShieldChallengeResponse instance.
    pub fn new(challenge_signature: [u8; 64], solution: i64) -> Self {
        Self {
            challenge_signature,
            solution,
        }
    }

    /// Concatenates the response data into a string.
    ///
    /// Concatenates:
    /// - `challenge_signature` as a lowercase hex string.
    /// - `solution`:           as a string.
    pub fn concat_struct(&self) -> String {
        format!(
            "{}|{}",
            // Use of hex::encode to convert the signature to a hex string
            // "Encodes data as hex string using lowercase characters."
            // Requirement of `format!`.
            hex::encode(self.challenge_signature),
            self.solution
        )
    }

    /// Creates an `IronShieldChallengeResponse` from a concatenated string.
    ///
    /// This function reverses the operation of
    /// `IronShieldChallengeResponse::concat_struct`.
    /// Expects a string in the format: "hex_signature|solution".
    ///
    /// # Arguments
    /// * `concat_string`: The concatenated string to parse, typically
    ///                    generated by `concat_struct()`.
    ///
    /// # Returns
    /// * `Result<Self, String>`: A result containing the parsed
    ///                           `IronShieldChallengeResponse`
    ///                           or an error message if parsing fails.
    pub fn from_concat_struct(concat_string: &str) -> Result<Self, String> {
        let parts: Vec<&str> = concat_string.split('|').collect();

        if parts.len() != 2 {
            return Err(format!("Expected 2 parts, got {}", parts.len()));
        }

        let signature_bytes = hex::decode(parts[0])
            .map_err(|_| "Failed to decode challenge_signature hex string")?;
        let challenge_signature: [u8; 64] = signature_bytes.try_into()
            .map_err(|_| "Challenge signature must be exactly 64 bytes")?;

        let solution = parts[1].parse::<i64>()
            .map_err(|_| "Failed to parse solution as i64")?;

        Ok(Self {
            challenge_signature,
            solution,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_concat_struct() {
        let response = IronShieldChallengeResponse::new([0; 64], 42);
        let concat = response.concat_struct();
        assert_eq!(concat, format!("{}|{}", hex::encode([0; 64]), 42.to_string()));
    }

    #[test]
    fn test_from_concat_struct() {
        let concat = format!("{}|{}", hex::encode([0; 64]), 42);
        let response = IronShieldChallengeResponse::from_concat_struct(&concat).unwrap();
        assert_eq!(response.challenge_signature, [0; 64]);
        assert_eq!(response.solution, 42);
    }

    #[test]
    fn test_from_concat_struct_edge_cases() {
        // Test with a valid minimum length hex (64 bytes = 128 hex chars).
        // Building a string programmatically.
        let valid_hex = "0".repeat(128);
        assert_eq!(valid_hex.len(), 128, "Hex string should be exactly 128 characters for 64 bytes");

        let input = format!("{}|0", valid_hex);
        let result = IronShieldChallengeResponse::from_concat_struct(&input);

        if result.is_err() {
            panic!("Expected success but got error: {}", result.unwrap_err());
        }

        let parsed = result.unwrap();
        assert_eq!(parsed.challenge_signature, [0u8; 64]);
        assert_eq!(parsed.solution, 0);

        // Test with all F's hex.
        let all_f_hex = "f".repeat(128);
        assert_eq!(all_f_hex.len(), 128, "All F's hex string should be exactly 128 characters");

        let input = format!("{}|-1", all_f_hex);
        let result = IronShieldChallengeResponse::from_concat_struct(&input);

        if result.is_err() {
            panic!("Expected success but got error: {}", result.unwrap_err());
        }

        let parsed = result.unwrap();
        assert_eq!(parsed.challenge_signature, [0xffu8; 64]);
        assert_eq!(parsed.solution, -1);
    }
}